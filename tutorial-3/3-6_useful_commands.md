# Tutorial 3-6: 便利なコマンド集

## 🎯 このセクションで学ぶこと

*   ファイルの中身をコマンドラインで確認する方法を学ぶ (`cat`, `less`)。
*   ファイルやディレクトリを検索する方法を学ぶ (`find`)。
*   コマンドの実行結果をファイルに書き出す方法（リダイレクト）を学ぶ。
*   複数のコマンドを繋げて、より強力な処理を行う方法（パイプ）を学ぶ。

---

## 導入

これまでに学んだコマンド (`pwd`, `ls`, `cd`, `mkdir`, `touch`, `mv`, `cp`, `rm`) は、コマンドラインの「基本の8単語」とも言える、非常に重要なものです。これらを使いこなせれば、基本的なファイル操作には困りません。

しかし、コマンドラインの世界には、まだまだ便利な道具（コマンド）がたくさんあります。例えるなら、今までは「歩く」「見る」「作る」「動かす」「捨てる」といった基本的な動詞だけを覚えてきた状態です。ここからは、「中を覗き見る」「探す」「記録する」「連携させる」といった、より高度で便利な動詞を覚えていきましょう。

このセクションで紹介するのは、単体でも便利ですが、特に**他のコマンドと組み合わせることで真価を発揮する**ものばかりです。これらのコマンドを習得することで、あなたのコマンドラインスキルは、単なるファイル操作から、データの加工や分析といった、より高度な領域へとステップアップします。

---

## 詳細解説

### ⚙️ 1. ファイルの中身を見る: `cat` と `less`

GUIではファイルをダブルクリックして内容を見ますが、CLIではどうするのでしょうか。2つの代表的なコマンドがあります。

#### `cat` (Concatenate)

`cat` は、ファイルの中身を**全て、一気に**ターミナルに表示するコマンドです。短い設定ファイルなどの内容を、さっと確認したい時に便利です。

```bash
# 練習用のファイルを作成
cd ~/practice
touch sample.txt

# VSCodeで sample.txt を開き、数行のテキストを書き込んで保存する
# (例: "Hello", "This is a sample file.", "Goodbye")

# catで中身を表示
cat sample.txt
# Hello
# This is a sample file.
# Goodbye
```

**注意点**: `cat` は、長いファイル（数千行あるログファイルなど）を表示させようとすると、ターミナルの画面が一瞬で文字で埋め尽くされてしまい、まともに読むことができません。そのような場合は、次に紹介する `less` を使います。

#### `less`

`less` は、長いファイルの内容を、**1画面ずつ、スクロールしながら**閲覧できるコマンドです。`cat` とは異なり、ファイル全体を一度に読み込まないため、巨大なファイルでも快適に開くことができます。

```bash
# lessで同じファイルを開く
less sample.txt
```

`less` を実行すると、ターミナルがファイル閲覧モードに切り替わります。以下のキーで操作できます。

*   **↓ / ↑ キー**: 1行ずつスクロール
*   **スペースキー**: 1画面分、次に進む
*   **`q` キー**: 閲覧を終了し、通常のプロンプトに戻る

短いファイルは `cat`、長いファイルは `less`。この使い分けを覚えましょう。

### ⚙️ 2. ファイルやディレクトリを検索する: `find`

`find` は、指定した場所から、条件に合うファイルやディレクトリを検索してくれる、非常に強力なコマンドです。

**基本構文:**

```bash
find [検索を開始する場所] -name "[検索したい名前]"
```

例えば、`practice` ディレクトリの中から、`sample.txt` という名前のファイルを検索してみましょう。

```bash
find . -name "sample.txt"
# ./sample.txt
```

*   `.` は「カレントディレクトリから」という意味です。
*   `-name` は「名前で検索する」というオプションです。
*   `"sample.txt"` のように、検索パターンはダブルクォーテーションで囲むのが安全です。

ワイルドカード `*` を使うと、より柔軟な検索ができます。例えば、「`.txt` で終わる全てのファイル」を検索するには、以下のようにします。

```bash
find . -name "*.txt"
# ./sample.txt
```

### ⚙️ 3. 出力をファイルに保存する: リダイレクト `>`

通常、コマンドの実行結果はターミナルの画面に表示されます。この出力の流れを、画面ではなく**ファイルに書き出す**機能のことを、**リダイレクト (Redirection)** と呼びます。記号 `>` を使います。

**基本構文:**

```bash
[コマンド] > [出力先のファイル名]
```

例えば、`ls` コマンドの結果を、画面ではなく `file_list.txt` というファイルに保存してみましょう。

```bash
ls > file_list.txt

# 画面には何も表示されない

# catでファイルの中身を確認
cat file_list.txt
# dir1
# dir1_copy
# file_list.txt
# sample.txt
```

`ls` の結果が、ターミナルには表示されず、代わりに `file_list.txt` に書き込まれていることが分かります。これは、コマンドの実行結果を記録しておきたい場合に、非常に便利です。

**注意**: `>` は、出力先のファイルが既に存在する場合、**中身を上書き**してしまいます。上書きではなく、**追記**したい場合は、`>>` を使います。

### ⚙️ 4. コマンドを連携させる: パイプ `|`

パイプは、コマンドラインをプログラミングたらしめる、最も強力な機能の一つです。あるコマンドの実行結果を、**別のコマンドの入力として直接渡す**ことができます。これにより、複数のシンプルなコマンドを繋ぎ合わせて、一つの複雑な処理を実現できます。

**基本構文:**

```bash
[コマンドA] | [コマンドB]
```

これは、「コマンドAの実行結果を、コマンドBに食べさせて、その結果を表示して」という意味になります。

例えば、「`ls -l`（ファイルの詳細一覧を表示するコマンド）の結果の中から、`sample` という単語が含まれている行だけを表示したい」というケースを考えてみましょう。ファイルの中から特定の単語を探す `grep` というコマンドと組み合わせます。

```bash
ls -l | grep "sample"
# -rw-r--r-- 1 user group 30 Dec 11 10:00 sample.txt
```

1.  まず `ls -l` が実行され、ファイル一覧の詳細情報が（画面には見えませんが）出力されます。
2.  その出力結果が、パイプ `|` を通じて、`grep "sample"` コマンドの入力になります。
3.  `grep` コマンドは、受け取った入力の中から `sample` という文字列を含む行だけを抜き出して、最終的な結果として画面に表示します。

このように、パイプ `|` を使うことで、「Aして、その結果をBして、さらにその結果をCする」といった、処理の連鎖を、たった1行で記述できるのです。

---

## ✨ まとめ

このセクションでは、コマンドラインの操作をより高度にする、4つの便利なテクニックを学びました。

| 機能 | コマンド/記号 | 説明 |
| :--- | :--- | :--- |
| **ファイル内容表示** | `cat [ファイル]` | ファイルの中身を全て表示する。短いファイル向け。 |
| | `less [ファイル]` | 1画面ずつスクロールしながら表示する。長いファイル向け。 |
| **検索** | `find [場所] -name "名前"` | 指定した場所からファイルやディレクトリを検索する。 |
| **出力の保存** | `>` (リダイレクト) | コマンドの実行結果を、画面ではなくファイルに書き出す（上書き）。 |
| | `>>` (リダイレクト) | ファイルに追記する。 |
| **コマンドの連携** | `|` (パイプ) | あるコマンドの出力を、別のコマンドの入力に渡す。 |

これらの機能を使いこなせるようになると、単にファイルを操作するだけでなく、ファイルの中身を調べたり、情報を整理したり、複数の処理を自動化したりと、コマンドラインでできることの幅が、飛躍的に広がります。

---

## 📝 学習のポイント

- [ ] `cat` と `less` の違いを説明でき、ファイルの長さに応じて使い分けることができる。
- [ ] `find` コマンドを使って、特定の名前のファイルを検索することができる。
- [ ] `>` を使って、コマンドの実行結果をファイルに保存できることを理解している。
- [ ] パイプ `|` が、コマンド同士を繋ぐための機能であることを説明できる。
