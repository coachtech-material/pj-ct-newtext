# Tutorial 8-1-4: 主キー（Primary Key）と外部キー（Foreign Key）

## 🎯 このセクションで学ぶこと

*   主キー（PK）が、「レコードを、一意に、識別するための、ID」であることを、理解する。
*   主キーの、2つの、重要な、ルール（重複不可、NULL不可）を、説明できるようになる。
*   外部キー（FK）が、「他の、テーブルの、主キーを、参照する、ID」であり、テーブル間の、「関係」を、作る役割を持つことを、理解する。
*   主キーと、外部キーの、組み合わせによって、データの、整合性が、保たれる仕組みを、説明できるようになる。

---

## 導入

前のセクションで、RDBは、テーブルを、分割し、IDを、使って、「関係」を、作る、という話をしました。この、「関係」を、作る上で、中心的な、役割を、果たすのが、**主キー（Primary Key）**と、**外部キー（Foreign Key）**です。

この、2つの、「キー」は、リレーショナルデータベースの、心臓部とも言える、非常に、重要な、概念です。なぜなら、これらが、あるおかげで、私たちは、データの、重複や、矛盾に、悩まされることなく、安全に、データを、管理することができるからです。

このセクションでは、主キーと、外部キー、それぞれの、役割と、ルール、そして、それらが、どのように連携して、テーブル間の、関係を、築いているのかを、詳しく、学んでいきます。

---

## 詳細解説

### 🔑 主キー (Primary Key): レコードの「背番号」

**主キー（Primary Key、略してPK）**とは、テーブル内の、**各レコードを、一意に（重複なく）、識別するための、特別な、カラム**のことです。

`customers`テーブルを、もう一度、見てみましょう。

**`customers` テーブル**

| `id` (顧客ID) | `name` (氏名) | `email` (メールアドレス) |
| :--- | :--- | :--- |
| 1 | 山田 太郎 | taro@example.com |
| 2 | 鈴木 花子 | hanako@example.com |
| 3 | 佐藤 次郎 | jiro@example.com |

このテーブルでは、`id`カラムが、主キーです。主キーは、レコードにとっての、**ユニークな、「背番号」や、「マイナンバー」**のようなものだと、考えてください。

もし、同姓同名の、「山田 太郎」さんが、二人、いたとしても、`id`が、`1`と`4`のように、異なっていれば、データベースは、二人を、明確に、区別することができます。

#### 主キーの絶対的なルール

あるカラムが、主キーになるためには、以下の、2つの、絶対的な、ルールを、満たさなければなりません。

1.  **一意性制約 (Unique): 値が、重複してはならない。**
    *   `id`が`1`の、レコードは、テーブル内に、ただ一つしか、存在できません。同じ`1`を、持つ、別のレコードを、追加しようとすると、データベースが、エラーを、返します。
2.  **非NULL制約 (NOT NULL): 値が、空（NULL）であってはならない。**
    *   主キーの、カラムには、必ず、何らかの、値が、入っていなければなりません。IDが、空の、レコードは、存在できません。

この、2つの、ルールによって、全ての、レコードが、必ず、一意の、識別子を、持つことが、保証されます。

一般的に、主キーには、`id`という名前を付け、**「オートインクリメント（Auto Increment）」**という、機能を、設定します。これは、新しい、レコードが、追加されるたびに、データベースが、自動的に、`1, 2, 3, ...` と、連番を、割り振ってくれる、便利な機能です。

### 🔗 外部キー (Foreign Key): 他のテーブルへの「参照」

**外部キー（Foreign Key、略してFK）**とは、**他の、テーブルの、主キーを、参照する、カラム**のことです。この、外部キーこそが、テーブルと、テーブルを、繋ぐ、「関係」の、正体です。

`orders`テーブルと、`customers`テーブルの、関係を、見てみましょう。

**`customers` テーブル (親テーブル)**

| `id` (PK) | `name` | `email` |
| :--- | :--- | :--- |
| **1** | 山田 太郎 | taro@example.com |
| **2** | 鈴木 花子 | hanako@example.com |

**`orders` テーブル (子テーブル)**

| `order_id` (PK) | `order_date` | `customer_id` (FK) |
| :--- | :--- | :--- |
| 101 | 2023-10-26 | **1** |
| 102 | 2023-10-27 | **2** |
| 103 | 2023-10-28 | **1** |

`orders`テーブルの、`customer_id`カラムが、外部キーです。このカラムには、`customers`テーブルの、主キーである、`id`の値が、格納されています。

*   注文ID `101` の、`customer_id`は `1` です。これは、`customers`テーブルの、`id`が`1`の、「山田 太郎」さんを、**参照**しています。
*   これにより、「注文ID `101` は、山田 太郎さんの、注文である」という、「**関係**」が、生まれます。

#### 外部キー制約による、データの整合性

外部キーには、**外部キー制約（Foreign Key Constraint）**という、特別な、ルールを、設定することができます。これは、データの、矛盾を、防ぐための、非常に、強力な、仕組みです。

外部キー制約を設定すると、データベースは、以下のことを、保証してくれます。

> **`orders`テーブルの、`customer_id`カラムには、`customers`テーブルの、`id`カラムに、実際に、存在する、値しか、登録できない。**

例えば、`customers`テーブルに、存在しない、顧客ID `99` を、持つ、注文を、登録しようとすると、どうなるでしょうか？

```sql
-- 存在しない顧客ID(99)で、注文を登録しようとする
INSERT INTO orders (order_id, order_date, customer_id) VALUES (104, '2023-10-29', 99);
```

外部キー制約が、設定されていれば、データベースは、「**エラー：顧客ID `99` は、`customers`テーブルに、存在しません**」と、この、`INSERT`処理を、拒否します。これにより、「どの顧客からの、注文か、分からない」といった、**孤児レコード**が、生まれるのを、防ぐことができます。

また、逆の、ケースも、考えてみましょう。もし、「山田 太郎」さん（顧客ID `1`）が、退会したとして、`customers`テーブルから、このレコードを、削除しようとしたら、どうなるでしょうか？

`orders`テーブルには、まだ、山田さんからの、注文履歴（`customer_id`が`1`のレコード）が、残っています。もし、`customers`テーブルから、山田さんの、レコードだけを、削除してしまうと、注文履歴の、`customer_id` `1` が、参照する先を、失ってしまいます。

外部キー制約は、このような、操作も、デフォルトでは、拒否します。「**エラー：この顧客は、注文履歴で、参照されているため、削除できません**」と、データの、整合性を、守ってくれるのです。

---

## ✨ まとめ

このセクションでは、リレーショナルデータベースの、心臓部である、主キーと、外部キーについて学びました。

*   **主キー (PK)**: テーブル内の、各レコードを、**一意に、識別する**ための、特別なカラム。「背番号」のようなもの。
    *   ルール: **重複不可 (Unique)** かつ **NULL不可 (NOT NULL)**。
    *   一般的に、`id`という名前で、オートインクリメント設定を、使用する。
*   **外部キー (FK)**: **他の、テーブルの、主キーを、参照する**ための、カラム。テーブル間の、「**関係**」を、定義する。
*   **外部キー制約**: 参照先の、テーブルに、存在しない、値を、登録できなくしたり、参照されている、レコードの、安易な、削除を、防いだりすることで、**データの、整合性を、自動的に、保ってくれる**、強力な、仕組み。

主キーが、「**私は、ID `1` の、山田です**」と、名乗るための、名札だとすれば、外部キーは、「**この注文は、ID `1` の、山田さんからのものです**」と、相手を、指し示す、ための、指示棒のようなものです。この、2つの、キーの、連携プレーによって、RDBは、その、真価を、発揮するのです。

---
