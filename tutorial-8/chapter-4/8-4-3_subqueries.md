
# Tutorial 8-4-3: サブクエリ - クエリの中にクエリを埋め込む

## 🎯 このセクションで学ぶこと

*   サブクエリ（副問い合わせ）が何であるか、その基本的な概念を理解する。
*   `WHERE`句の中でサブクエリを使い、動的な条件（別のクエリの結果）に基づいてデータを絞り込めるようになる。
*   `FROM`句の中でサブクエリ（インラインビュー）を使い、クエリの結果を一時的なテーブルとして扱えるようになる。
*   `EXISTS`演算子とサブクエリを組み合わせ、関連データの「存在有無」を効率的にチェックできるようになる。
*   どのような時にサブクエリを使い、どのような時に`JOIN`を使うべきか、その使い分けの指針を理解する。

---

## 導入：一度の問い合わせでは答えられない問い

SQLの強力な機能を学んできましたが、それでも一度の単純なクエリでは答えられない問いが存在します。例えば、こんな問いを考えてみましょう。

> 「全ユーザーの平均投稿数を算出し、その**平均よりも多くの投稿をしているユーザー**は誰か？」

この問いに答えるには、2つのステップが必要です。

1.  まず、ユーザーごとの投稿数を集計し、さらにその平均値を計算する。（ステップ1：平均値の算出）
2.  次に、各ユーザーの投稿数が、ステップ1で算出した平均値よりも大きいかどうかを比較する。（ステップ2：ユーザーの絞り込み）

これらを別々のクエリで実行し、アプリケーション側で組み合わせることも可能ですが、SQLには、このような複数のステップを一つの洗練されたクエリで実行するための仕組みがあります。それが**サブクエリ（Subquery）**、または**副問い合わせ**です。

サブクエリは、SQL文の中に別の`SELECT`文を入れ子のように埋め込むテクニックです。これをマスターすることで、より複雑で動的なデータ抽出が可能になり、SQLで表現できることの幅が大きく広がります。このチュートリアル「SQL基礎」の締めくくりとして、この強力な概念を学びましょう。

---

## 詳細解説

### 🧩 サブクエリとは？

サブクエリとは、その名の通り「副」のクエリで、別のSQL文（メインクエリ）の一部として機能します。`()`で囲まれた`SELECT`文の形をしています。

基本的なルールはシンプルです。

*   サブクエリは`()`で囲む。
*   **サブクエリ（内側のクエリ）が先に実行される。**
*   **メインクエリ（外側のクエリ）は、サブクエリの実行結果を利用して実行される。**

サブクエリは、`SELECT`, `FROM`, `WHERE`, `HAVING`など、様々な句の中に配置することができます。

### 1. `WHERE`句で使うサブクエリ

最も一般的で直感的な使い方です。`WHERE`句の比較対象となる値を、別のクエリで動的に生成します。

#### 単一の値を返すサブクエリ（スカラ・サブクエリ）

サブクエリが単一のカラム・単一の行（つまり、一つの値）を返すパターンです。

**例：`posts`テーブルの平均文字数より多い文字数の投稿を探す**

```sql
SELECT
    id, title, LENGTH(content) AS content_length
FROM
    posts
WHERE
    LENGTH(content) > (SELECT AVG(LENGTH(content)) FROM posts);
```

1.  まずサブクエリ `(SELECT AVG(LENGTH(content)) FROM posts)` が実行され、投稿内容の平均文字数（例えば`550.75`）という一つの値が計算されます。
2.  次にメインクエリが、その結果を使って `WHERE LENGTH(content) > 550.75` という形で実行されます。

#### 複数の値を返すサブクエリ (`IN`演算子と共に使う)

サブクエリが単一のカラム・複数の行（つまり、値のリスト）を返すパターンです。`IN`演算子と組み合わせることで、「サブクエリの結果リストに含まれる値」という条件を作成できます。

**例：タグが1つも付いていない投稿を探す**

```sql
SELECT * FROM posts
WHERE id NOT IN (SELECT DISTINCT post_id FROM post_tag);
```

1.  サブクエリ `(SELECT DISTINCT post_id FROM post_tag)` が実行され、`post_tag`テーブルに存在する全ての`post_id`のリスト（例えば `(1, 2, 5, 8, ...)`）が生成されます。
2.  メインクエリが、その結果を使って `WHERE id NOT IN (1, 2, 5, 8, ...)` という形で実行され、リストに含まれていない投稿IDを持つレコードを抽出します。

### 2. `FROM`句で使うサブクエリ（インラインビュー）

`FROM`句にサブクエリを置くと、そのサブクエリの実行結果を、あたかも一つの**仮想的なテーブル（ビュー）**のように扱うことができます。これを**インラインビュー**と呼びます。

*   インラインビューには、`AS`を使って**必ず別名を付ける必要があります。**

**例：導入で提示した「平均投稿数よりも多くの投稿をしているユーザー」を探す**

```sql
SELECT
    u.name,
    user_post_counts.post_count
FROM
    users AS u
JOIN
    -- ① ユーザーごとの投稿数を計算するインラインビュー
    (
        SELECT user_id, COUNT(id) AS post_count
        FROM posts
        GROUP BY user_id
    ) AS user_post_counts ON u.id = user_post_counts.user_id
WHERE
    user_post_counts.post_count > 
    -- ② 全投稿のユーザーごとの平均投稿数を計算するサブクエリ
    (
        SELECT AVG(post_count) 
        FROM (
            SELECT COUNT(id) AS post_count 
            FROM posts 
            GROUP BY user_id
        ) AS avg_counts
    );
```
これは非常に複雑に見えますが、分解すれば理解できます。

*   `①`のインラインビューは、`user_id`と`post_count`という2つのカラムを持つ`user_post_counts`という名前の一時的なテーブルを生成します。
*   メインクエリは、`users`テーブルとこの`user_post_counts`テーブルを`JOIN`します。
*   `②`のサブクエリは、さらにその中でインラインビューを使い、ユーザーごとの投稿数の平均値を計算しています。

このように、サブクエリを入れ子にすることで、非常に複雑な集計や比較が可能になります。

### 3. `EXISTS`演算子で使うサブクエリ

`EXISTS`は、サブクエリが**1件でもレコードを返せば`TRUE`**、1件も返さなければ`FALSE`を返す演算子です。関連データの「**存在チェック**」に特化しており、`IN`や`JOIN`よりも効率的な場合があります。

**例：一度でも投稿をしたことがあるユーザーの情報を取得する**

```sql
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM posts p WHERE p.user_id = u.id
);
```

*   メインクエリの`users`テーブルの各行（`u`）に対して、サブクエリが実行されます。
*   サブクエリは、`posts`テーブルの中に、現在のユーザーID（`u.id`）と一致する`user_id`を持つレコードが**存在するかどうか**だけをチェックします。
*   `SELECT 1`となっているのは、サブクエリ内で何のカラムを返すかは重要ではなく、単にレコードが1件でも見つかれば、その時点で`EXISTS`は`TRUE`となり、チェックを終了するからです。これにより、不要なデータ取得がなくなり、パフォーマンスが向上します。

### サブクエリ vs `JOIN`

「一度でも投稿をしたことがあるユーザー」は、`JOIN`, `IN`, `EXISTS`のいずれを使っても取得できます。どれを使うべきでしょうか？

*   **`JOIN`**: 関連テーブルのデータも一緒に取得したい場合に最適。
*   **`IN`**: サブクエリの結果リストが小さい場合に直感的で分かりやすい。
*   **`EXISTS`**: 単純な存在チェックが目的の場合に最も効率的であることが多い。

絶対的な正解はなく、クエリの**可読性**（他の人が読んで意図が分かるか）と**パフォーマンス**のバランスを考えて選択するのが良いでしょう。初めのうちは、自分が最も理解しやすい方法で書き、慣れてきたら他の書き方も試してみるのがお勧めです。

---

## ✨ まとめ

このセクションでは、SQLの応用テクニックであるサブクエリについて学びました。

*   サブクエリは、SQL文の中に`()`で埋め込まれた`SELECT`文で、メインクエリより先に実行される。
*   `WHERE`句でサブクエリを使うと、別のクエリの結果を条件として利用できる。
*   `FROM`句でサブクエリ（インラインビュー）を使うと、集計結果などを一時的なテーブルとして扱え、さらに複雑なクエリを組み立てられる。
*   `EXISTS`は、関連データの存在チェックに特化した効率的な方法を提供する。
*   多くのサブクエリは`JOIN`で書き換え可能であり、可読性やパフォーマンスを考慮して使い分けることが重要。

これで、Tutorial 8「SQL基礎とデータベース設計」は完了です！基本的なCRUD操作から始まり、正規化、リレーションシップ、JOIN、そしてサブクエリまで、リレーショナルデータベースを扱う上で必須となる知識を一通り学びました。ここで得たSQLの知識は、この先のLaravelでの開発において、Eloquent ORMの裏側で何が起きているかを理解し、より高度な機能を実装するための強固な土台となります。

---
