
# Tutorial 8-3-2: 1対多のリレーションシップ - 投稿テーブルを作成し、ユーザーと繋げよう

## 🎯 このセクションで学ぶこと

*   最も基本的な「1対多」のリレーションシップを、SQLを使って物理的に実装できるようになる。
*   `CREATE TABLE`文の中で`FOREIGN KEY`制約を定義する方法を理解する。
*   外部キー制約がデータの整合性をどのように守るのか（存在しない親レコードへの関連付けを防ぐ仕組み）を理解する。
*   `ON DELETE CASCADE`オプションの役割と、それによって何が起こるのかを説明できるようになる。
*   phpMyAdminのデザイナー機能で、作成したリレーションシップが視覚的に表示されることを確認する。

---

## 導入：設計図から建築へ

前のセクションで、私たちはデータベースの「設計図」であるER図の読み方を学びました。そして、「1人のユーザーが複数の投稿を持つ」という「1対多」の関係が、多くのアプリケーションの基本となることを見てきました。

いよいよ、その設計図をもとに、実際のテーブルを組み立てていく工程に入ります。具体的には、新しく「投稿」を管理するための`posts`テーブルを作成し、それを既存の`users`テーブルと「1対多」の関係で結びつけます。

このセクションで行う「外部キー制約（Foreign Key Constraint）」の設定は、リレーショナルデータベースにおける最も重要な概念の一つです。これは、テーブル間の関係を定義するだけでなく、無効なデータが登録されるのを防ぎ、データベース全体の**整合性（Integrity）**を守るための「門番」のような役割を果たします。この門番の仕組みをSQLレベルでしっかり理解することが、堅牢なアプリケーションを作るための第一歩です。

---

## 詳細解説

### 1. `posts`テーブルの設計

まず、`posts`テーブルにどのようなカラム（アトリビュート）が必要かを考えます。

*   `id`: 投稿を一意に識別するための主キー。
*   `user_id`: **どのユーザー**がこの投稿をしたのかを記録するための外部キー。`users`テーブルの`id`を参照します。
*   `title`: 投稿のタイトル。
*   `content`: 投稿の本文。
*   `created_at`, `updated_at`: レコードの作成日時と更新日時。

この設計をもとに、`CREATE TABLE`文を作成していきます。

### 2. 外部キー制約 (`FOREIGN KEY`) の設定

`posts`テーブルを作成するSQL文の中で、`user_id`が`users`テーブルの`id`を参照する外部キーであることを明示します。これがリレーションシップの物理的な実装です。

```sql
CREATE TABLE posts (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    user_id BIGINT UNSIGNED NOT NULL,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    
    -- ここがリレーションシップの定義
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

このSQL文の最後の行が、このセクションの核心です。

`FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE`

これを分解して見ていきましょう。

*   `FOREIGN KEY (user_id)`: このテーブルの`user_id`カラムを外部キーとして設定しますよ、という宣言です。
*   `REFERENCES users(id)`: この外部キーは、`users`テーブルの`id`カラムを参照（`REFERENCES`）しますよ、という指定です。これにより、`posts`テーブルの`user_id`には、`users`テーブルに**実際に存在する`id`の値しか**入れられなくなります。
*   `ON DELETE CASCADE`: 「もし参照先の親レコード（`users`テーブルのレコード）が削除（`DELETE`）されたら、この子レコード（`posts`テーブルの関連レコード）も自動的に一緒に削除（`CASCADE`）してください」という設定です。つまり、あるユーザーが退会して`users`テーブルから削除されたら、そのユーザーが行った投稿もすべて自動で削除されるようになります。これにより、持ち主のいない「孤児レコード」が発生するのを防ぎ、データの整合性を保ちます。

### 3. SQLの実行と確認

それでは、phpMyAdminで上記のSQL文を実行してみましょう。

1.  phpMyAdminで`practice_db`データベースを選択し、「SQL」タブを開きます。
2.  上記の`CREATE TABLE`文を貼り付けて、「実行」ボタンをクリックします。
3.  「テーブル `posts` を作成しました」というメッセージが表示されれば成功です。左側のテーブル一覧に`posts`テーブルが追加されていることを確認してください。

**[ここに、`posts`テーブルが作成された後のphpMyAdminのスクリーンショットを挿入]**

### 4. デザイナーで関係性を視覚的に確認する

次に、このリレーションシップが正しく設定されたか、ER図で確認してみましょう。

1.  上部タブの「その他」から「デザイナー」を選択します。
2.  画面上に`users`テーブルと`posts`テーブルが表示され、`users`テーブルの`id`から`posts`テーブルの`user_id`に向かって線が引かれているはずです。

**[ここに、`users`と`posts`が線で結ばれたデザイナー画面のスクリーンショットを挿入]**

この線が、私たちがSQLで定義した「1対多」のリレーションシップそのものです。設計図が、現実のデータベース構造として具現化した瞬間です。

### 5. 外部キー制約の効果を試す

では、この「門番」が本当に機能しているか試してみましょう。

#### 成功する例：存在するユーザーで投稿を作成

まず、`users`テーブルに`id=1`のユーザーが存在することを確認してください。

> ⚠️ **確認方法**：phpMyAdminで`users`テーブルを開き、データが存在するか確認してください。もし`users`テーブルが空の場合は、Tutorial 8-2-3でユーザーを追加していない可能性があります。以下のSQLを実行して、テスト用のユーザーを追加してください。
>
> ```sql
> INSERT INTO users (name, email, password)
> VALUES ('John Doe', 'john.doe@example.com', 'password123');
> ```

ユーザーが存在することを確認したら、`id=1`のユーザーが新しい投稿をする、という`INSERT`文を実行します。

```sql
INSERT INTO posts (user_id, title, content) VALUES (1, '初めての投稿', 'リレーションシップを学びました！');
```

これは問題なく成功し、`posts`テーブルに新しいレコードが追加されます。

#### 失敗する例：存在しないユーザーで投稿を作成

次に、`users`テーブルに存在しない`user_id`（例えば`999`）を使って投稿を作成しようとするとどうなるでしょうか。

```sql
INSERT INTO posts (user_id, title, content) VALUES (999, '存在しないユーザーの投稿', 'この投稿は追加できる？');
```

このSQLを実行すると、データベースはエラーを返します。

`Cannot add or update a child row: a foreign key constraint fails ...`

**[ここに、外部キー制約違反のエラーメッセージが表示されたスクリーンショットを挿入]**

これは、外部キー制約（門番）が「`users`テーブルに`id=999`のユーザーは存在しません。したがって、この投稿は許可できません」と、不正なデータの挿入をブロックしてくれた証拠です。このようにして、データベースはデータの整合性を自動的に守ってくれるのです。

---

## ✨ まとめ

このセクションでは、「1対多」のリレーションシップを物理的に作成する方法を学びました。

*   `CREATE TABLE`文の中で`FOREIGN KEY`句を使うことで、テーブル間のリレーションシップを定義できる。
*   `REFERENCES`で参照先の親テーブルと主キーを指定する。
*   外部キー制約は、存在しない親レコードへの関連付けを防ぎ、データの整合性を保つ「門番」の役割を果たす。
*   `ON DELETE CASCADE`オプションを設定すると、親レコードの削除に追随して、関連する子レコードも自動的に削除される。
*   phpMyAdminのデザイナー機能を使えば、作成したリレーションシップをER図として視覚的に確認できる。

SQLレベルでリレーションシップを実装し、その挙動を理解することは、この先のLaravelでの開発をスムーズに進める上で極めて重要です。次のセクションでは、もう一つの重要なリレーションシップである「多対多」について学んでいきましょう。

---
