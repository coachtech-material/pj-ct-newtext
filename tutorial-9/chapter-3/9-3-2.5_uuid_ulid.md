# Tutorial 9-3-2.5: UUIDとULID - 主キーの代替手段

## 🎯 このセクションで学ぶこと

*   UUID（Universally Unique Identifier）とULID（Universally Unique Lexicographically Sortable Identifier）が何であるか理解する。
*   自動増分ID（`$table->id()`）とUUID/ULIDの違いを説明できるようになる。
*   マイグレーションでUUID/ULIDカラムを定義できるようになる。
*   EloquentモデルでUUID/ULIDを主キーとして使用できるようになる。

---

## 導入：なぜ自動増分ID以外の選択肢が必要なのか？

前のセクションで、`$table->id()`を使って自動増分の主キーを作成する方法を学びました。これは最も一般的な方法ですが、以下のような場面では問題が生じることがあります。

*   **分散システム**: 複数のサーバーで同時にデータを作成する場合、自動増分IDでは衝突が起きる可能性がある。
*   **セキュリティ**: URLに`/users/1`、`/users/2`のようにIDが露出すると、総数が推測されたり、他のユーザーのデータにアクセスしようとする攻撃を受けやすくなる。
*   **データ移行**: 異なるシステム間でデータを移行する際、自動増分IDでは衝突が起きやすい。

これらの問題を解決するのが、**UUID**と**ULID**です。

---

## 詳細解説

### 🔑 UUIDとは？

**UUID（Universally Unique Identifier）**は、世界中で一意であることが保証された128ビットの識別子です。以下のような形式で表現されます。

```
550e8400-e29b-41d4-a716-446655440000
```

UUIDは、ランダムに生成されるため、事前に調整しなくても、異なるシステムで同時に生成しても衝突する可能性が極めて低いです。

#### UUIDの特徴

| 特徴 | 説明 |
|:---|:---|
| **一意性** | 世界中で一意であることが保証される |
| **予測不可能** | ランダムに生成されるため、次のIDを予測できない |
| **分散生成** | 中央サーバーなしで、どこでも生成できる |
| **長い** | 36文字（ハイフン含む）と、自動増分IDより長い |
| **ソート不可** | 生成順序でソートできない（バージョン7を除く） |

---

### 🔑 ULIDとは？

**ULID（Universally Unique Lexicographically Sortable Identifier）**は、UUIDの欠点を補うために設計された識別子です。以下のような形式で表現されます。

```
01ARZ3NDEKTSV4RRFFQ69G5FAV
```

ULIDは、**タイムスタンプ部分**と**ランダム部分**で構成されており、生成順序でソートできるという特徴があります。

#### ULIDの特徴

| 特徴 | 説明 |
|:---|:---|
| **一意性** | UUIDと同様に、世界中で一意 |
| **ソート可能** | 生成順序でソートできる（タイムスタンプを含む） |
| **短い** | 26文字と、UUIDより短い |
| **URL安全** | ハイフンを含まず、URLに使いやすい |
| **予測不可能** | ランダム部分があるため、次のIDを予測できない |

---

### 📊 自動増分ID、UUID、ULIDの比較

| 項目 | 自動増分ID | UUID | ULID |
|:---|:---|:---|:---|
| **形式** | `1`, `2`, `3`... | `550e8400-e29b-...` | `01ARZ3NDEKTSV4...` |
| **長さ** | 可変（最大20桁） | 36文字 | 26文字 |
| **一意性** | データベース内で一意 | 世界中で一意 | 世界中で一意 |
| **予測可能性** | 予測可能 | 予測不可能 | 予測不可能 |
| **ソート** | 生成順でソート可能 | ソート不可 | 生成順でソート可能 |
| **分散生成** | 不可（中央管理が必要） | 可能 | 可能 |
| **ストレージ** | 8バイト | 16バイト | 16バイト |
| **インデックス効率** | 高い | 低い（ランダムなため） | 高い（ソート可能なため） |

---

### 🛠️ マイグレーションでUUID/ULIDを使う

#### UUIDカラムの定義

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('posts', function (Blueprint $table) {
            // UUIDを主キーとして使用
            $table->uuid('id')->primary();
            
            $table->string('title');
            $table->text('content');
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('posts');
    }
};
```

**コードリーディング**

*   `$table->uuid('id')`: UUID型のカラムを作成します。MySQLでは`CHAR(36)`として保存されます。
*   `->primary()`: このカラムを主キーとして設定します。

#### ULIDカラムの定義

```php
Schema::create('posts', function (Blueprint $table) {
    // ULIDを主キーとして使用
    $table->ulid('id')->primary();
    
    $table->string('title');
    $table->text('content');
    $table->timestamps();
});
```

**コードリーディング**

*   `$table->ulid('id')`: ULID型のカラムを作成します。MySQLでは`CHAR(26)`として保存されます。

#### 外部キーとしてUUID/ULIDを使う

```php
Schema::create('comments', function (Blueprint $table) {
    $table->ulid('id')->primary();
    
    // 外部キーもULID型で定義
    $table->foreignUlid('post_id')->constrained()->onDelete('cascade');
    
    $table->text('body');
    $table->timestamps();
});
```

**コードリーディング**

*   `$table->foreignUlid('post_id')`: ULID型の外部キーカラムを作成します。
*   `->constrained()`: 自動的に`posts`テーブルの`id`カラムを参照する外部キー制約を設定します。

同様に、UUIDの場合は`$table->foreignUuid('post_id')`を使用します。

---

### 🧩 EloquentモデルでUUID/ULIDを使う

マイグレーションでUUID/ULIDカラムを定義したら、Eloquentモデルでも対応する設定が必要です。

#### UUIDを使うモデル

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Model;

class Post extends Model
{
    use HasUuids;
    
    // UUIDは文字列なので、キャストを設定
    protected $keyType = 'string';
    
    // 自動増分を無効化
    public $incrementing = false;
}
```

**コードリーディング**

*   `use HasUuids;`: このトレイトを使うことで、モデル作成時に自動的にUUIDが生成されます。
*   `protected $keyType = 'string';`: 主キーの型を文字列に設定します（デフォルトは`int`）。
*   `public $incrementing = false;`: 自動増分を無効化します。

#### ULIDを使うモデル

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUlids;
use Illuminate\Database\Eloquent\Model;

class Post extends Model
{
    use HasUlids;
    
    protected $keyType = 'string';
    public $incrementing = false;
}
```

**コードリーディング**

*   `use HasUlids;`: このトレイトを使うことで、モデル作成時に自動的にULIDが生成されます。

#### 使用例

```php
// 新しい投稿を作成
$post = Post::create([
    'title' => 'ULIDを使った投稿',
    'content' => 'ULIDは自動的に生成されます。',
]);

echo $post->id; // 例: 01HX5QJKM8VGZN3YWDCR4BFPST

// IDで検索
$post = Post::find('01HX5QJKM8VGZN3YWDCR4BFPST');
```

---

### 🔍 どれを選ぶべきか？

| ユースケース | 推奨 |
|:---|:---|
| **一般的なWebアプリケーション** | 自動増分ID（`$table->id()`） |
| **URLにIDを露出させたくない** | UUID または ULID |
| **分散システム、マイクロサービス** | UUID または ULID |
| **時系列でソートしたい** | ULID |
| **既存システムとの互換性が必要** | UUID |
| **ストレージ効率を重視** | 自動増分ID |

#### 実務でのアドバイス

1. **迷ったら自動増分IDを使う**: 多くの場合、自動増分IDで十分です。シンプルで、パフォーマンスも良いです。

2. **セキュリティが重要な場合はULIDを検討**: ユーザーIDや注文IDなど、URLに露出するIDは、ULIDを使うことで予測を防げます。

3. **UUIDよりULIDを優先**: 特別な理由がない限り、ULIDの方がソート可能でインデックス効率も良いため、ULIDを選ぶことをお勧めします。

---

## 💡 TIP: UUID v7について

UUID v7は、ULIDと同様にタイムスタンプを含むUUIDのバージョンです。Laravel 11以降では、`Str::uuid7()`で生成できます。

```php
use Illuminate\Support\Str;

$uuid7 = Str::uuid7(); // 例: 018f6b1c-7a8d-7000-8000-000000000000
```

UUID v7は、既存のUUIDインフラとの互換性を保ちながら、ソート可能という利点があります。

---

## ✨ まとめ

このセクションでは、主キーの代替手段としてUUIDとULIDを学びました。

*   **UUID**は、世界中で一意な128ビットの識別子で、分散システムやセキュリティが重要な場面で使われる。
*   **ULID**は、UUIDの欠点を補い、ソート可能で短い識別子である。
*   マイグレーションでは、`$table->uuid()`や`$table->ulid()`でカラムを定義する。
*   Eloquentモデルでは、`HasUuids`や`HasUlids`トレイトを使って、自動的にID生成を行う。
*   一般的なWebアプリケーションでは自動増分IDで十分だが、セキュリティや分散システムではUUID/ULIDを検討する。

次のセクションでは、マイグレーションの実行とロールバックについて詳しく学びます。

---
