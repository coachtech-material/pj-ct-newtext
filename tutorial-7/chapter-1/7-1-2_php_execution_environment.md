# Tutorial 7-1-2: PHPの実行環境

## 🎯 このセクションで学ぶこと

*   PHPのコードが、どのようにして実行され、ブラウザに表示されるのか、その一連の流れを理解する。
*   Tutorial 6で構築したDocker環境（Nginx, PHP-FPM）が、PHPの実行において、どのような役割を果たしているのかを理解する。
*   実際に、Dockerコンテナの中で、PHPのコードを書いて、実行してみる。

---

## 導入

前のセクションで、PHPがサーバーサイドで実行される言語であることを学びました。では、具体的に、「サーバーサイドで実行される」とは、どういうことなのでしょうか？

HTMLファイルであれば、PC上のファイルを、直接ブラウザで開けば、その内容が表示されました。しかし、PHPファイルは、同じように、直接ブラウザで開いても、`<?php ... ?>` というコードが、そのまま表示されてしまうだけで、意図した通りには動作しません。

PHPのコードを実行するには、**Webサーバー**と**PHP実行エンジン**という、2つの要素から成る、特別な「舞台装置」が必要です。このセクションでは、この舞台装置の仕組みと、私たちがTutorial 6で構築したDocker環境が、まさに、その舞台装置そのものであることを、解き明かしていきます。

---

## 詳細解説

### 🎭 PHPが実行されるまでの流れ

ユーザーが、ブラウザで、PHPのページ（例: `index.php`）にアクセスしてから、その結果が、画面に表示されるまで、サーバーの裏側では、以下のような、一連のドラマが繰り広げられています。

1.  **リクエスト (Request)**: ユーザーのブラウザが、Webサーバー（例: Nginx）に対して、「`index.php`のページをください」という、HTTPリクエストを送信します。

2.  **処理の委譲 (Delegation)**: リクエストを受け取ったWebサーバー（Nginx）は、アクセスされたファイルの拡張子が `.php` であることを認識します。Nginx自身は、PHPを実行する能力を持っていないため、「これは私の仕事ではない。専門家にお願いしよう」と考え、リクエストを、PHPの実行を専門とする、**PHP-FPM (FastCGI Process Manager)** というプログラムに、丸投げします。

3.  **PHPの実行 (Execution)**: リクエストを受け取ったPHP-FPMは、PHPの実行エンジン（PHPインタープリタ）を起動し、`index.php`ファイルの内容を、上から順に解釈・実行します。データベースへの問い合わせや、複雑な計算など、全ての「動的な」処理は、この段階で行われます。

4.  **HTMLの生成 (Generation)**: PHP-FPMは、PHPコードの実行結果（例: `echo`で出力された文字列など）を、元のHTMLコードに埋め込み、最終的な、**純粋なHTML**の文字列を生成します。

5.  **レスポンス (Response)**: 生成された純粋なHTMLは、再び、Webサーバー（Nginx）に返されます。そして、Webサーバーは、そのHTMLを、HTTPレスポンスとして、ユーザーのブラウザに送信します。

6.  **レンダリング (Rendering)**: ブラウザは、受け取ったHTMLを解釈し、画面に、美しく表示（レンダリング）します。ブラウザから見れば、それが、元々、PHPファイルだったのか、静的なHTMLファイルだったのかは、全く区別がつきません。ただ、完成品のHTMLが送られてきた、と認識するだけです。

![PHP Execution Flow](https://i.imgur.com/ABCDE12.png)  *ここに、上記6ステップを図解した画像を挿入*

### 🐳 Docker環境との対応

この一連の流れを、私たちが構築した`docker-compose.yml`と、見比べてみましょう。

```yaml
# docker-compose.yml

services:
  # 1. Webサーバー (Nginx)
  nginx:
    image: nginx:latest
    ports:
      - "8000:80"
    # ...
    depends_on:
      - php # 2. PHP-FPMに処理を渡す

  # 3. PHP実行環境 (PHP-FPM)
  php:
    build:
      context: ./docker/php
    # ...
```

見事に、先ほどの流れと、対応していることがわかりますね。

*   `nginx`サービスが、**Webサーバー**の役割を果たします。`ports`の設定により、外部（私たちのブラウザ）からのリクエストを、8000番ポートで受け付けます。
*   `php`サービスが、**PHP-FPM**の役割を果たします。`nginx`の設定ファイル（`default.conf`）の中で、「`.php`へのアクセスは、`php`という名前のサービス（コンテナ）に渡しなさい」という設定が、記述されています。（`fastcgi_pass php:9000;` の部分）

このように、Docker Composeを使うことで、本来であれば、複雑な設定が必要な、WebサーバーとPHP-FPMの連携を、非常にシンプルに、実現できているのです。

### ✍️ 最初のPHPコードを書いてみよう

それでは、実際に、この環境で、PHPのコードを書いて、動かしてみましょう。

1.  **プロジェクトの起動**: Tutorial 6で作成した、`laravel-project`ディレクトリに移動し、以下のコマンドで、環境を起動します。（すでに起動している場合は不要です）

    ```bash
    docker-compose up -d
    ```

2.  **PHPファイルの作成**: `src`ディレクトリの中に、`index.php`というファイルを作成します。`src`ディレクトリは、`nginx`と`php`の両方のコンテナから、`/var/www/html`として、見えるように設定されていますね。

    ```php
    // src/index.php

    <!DOCTYPE html>
    <html lang="ja">
    <head>
        <meta charset="UTF-8">
        <title>はじめてのPHP</title>
    </head>
    <body>
        <h1>PHPの世界へようこそ！</h1>
        <p>PHPを使って、動的なコンテンツを表示してみましょう。</p>
        <p>1 + 1 は、<?php echo 1 + 1; ?> です。</p>
        <p>現在の日時は、<?php echo date("Y年m月d日 H時i分s秒"); ?> です。</p>
    </body>
    </html>
    ```

3.  **ブラウザで確認**: Webブラウザで、`http://localhost:8000/index.php` にアクセスします。

    画面に、「1 + 1 は、2 です。」や、現在の日時が、正しく表示されていれば、成功です！ブラウザの「ページのソースを表示」機能で、ソースコードを確認してみてください。`<?php ... ?>`の部分は、完全に消え、その実行結果である「2」や、日時の文字列に、置き換わっていることが、確認できるはずです。

---

## ✨ まとめ

このセクションでは、PHPのコードが、サーバーの裏側で、どのように実行されるのか、その具体的な流れを学びました。

*   **PHPの実行フロー**: `ブラウザ → Webサーバー(Nginx) → PHP-FPM → Webサーバー(Nginx) → ブラウザ` という流れで、処理が進む。
*   **役割分担**: Nginxは、リクエストの受付と、静的ファイルの配信、PHP-FPMへの処理の委譲を担当する。PHP-FPMは、PHPコードの実行と、HTMLの生成を担当する。
*   **Docker環境**: 私たちが構築したDocker環境は、このNginxとPHP-FPMの連携を、`docker-compose.yml`によって、簡単に実現している。
*   **動作確認**: `src`ディレクトリに、PHPファイルを作成し、`localhost:8000`にアクセスすることで、PHPが、正常に動作していることを確認した。

この、サーバーの裏側で起きている、一連のドラマを、イメージできるようになることは、今後の学習や、エラー解決において、非常に大きな助けとなります。次のセクションから、いよいよ、PHPの、具体的な文法について、学んでいきましょう。

---

## 📝 学習のポイント

- [ ] PHPのコードが、サーバーで実行され、純粋なHTMLとして、ブラウザに返される流れを説明できる。
- [ ] NginxとPHP-FPMの、それぞれの役割を説明できる。
- [ ] Docker環境で、簡単なPHPファイルを作成し、ブラウザで、その実行結果を確認できる。
